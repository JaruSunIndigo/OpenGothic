#version 450

#extension GL_EXT_control_flow_attributes : enable
#extension GL_GOOGLE_include_directive    : enable

#include "scene.glsl"
#include "common.glsl"

#if defined(CLEAR)
layout(local_size_x = 64) in;
#else
layout(local_size_x = 8, local_size_y = 8) in;
#endif

const int MAX_DEBUG_COLORS = 10;
const vec3 debugColors[MAX_DEBUG_COLORS] = {
  vec3(1,1,1),
  vec3(0,0,1),
  vec3(0,1,0),
  vec3(1,0,0),
  vec3(1,1,0),
  vec3(1,0,1),
  vec3(0,1,1),
  vec3(1,0.5,0),
  vec3(0.5,1,0),
  vec3(0,0.5,1),
  };

const float gridStep = 50;

struct Hash {
  uint value;
  };

struct Probe {
  vec3 pos;
  uint tid;
  vec3 color;
  };

layout(binding = 0, std140) uniform UboScene {
  SceneDesc scene;
  };

layout(binding = 1) uniform sampler2D diffuse;
layout(binding = 2) uniform sampler2D normals;
layout(binding = 3) uniform sampler2D depth;
layout(binding = 4, std430) buffer Hbo { Hash hashTable[]; };
layout(binding = 5, std430) buffer Pbo { uint probeCount; Probe probe[]; };

ivec2 screenSize, fragCoord;
uint  threadId;

uint hash(ivec3 pos) {
  return (pos.x * 18397) + (pos.y * 20483) + (pos.z * 29303);
  }

void processProbe(ivec3 gridPos, vec3 pos, int lod) {
  const uint h = hash(gridPos) % hashTable.length();
#if defined(PREPASS)
  atomicMin(hashTable[h].value, threadId);
#else
  if(hashTable[h].value != threadId)
    return;
  const uint cursor = atomicAdd(probeCount, 1);
  if(cursor>=probe.length())
    return;
  Probe p;
  p.pos   = pos;
  p.tid   = threadId;
  p.color = debugColors[lod%MAX_DEBUG_COLORS]; //vec3(0,0,1);

  probe[cursor] = p;
#endif
  }

vec3 unprojectDepth(const float z) {
  const vec2  inPos = vec2(2*fragCoord+ivec2(1,1))/vec2(screenSize)-vec2(1,1);
  const vec4  pos   = vec4(inPos.xy,z,1);
  const vec4  ret   = scene.viewProjectInv*pos;
  return (ret.xyz/ret.w);
  }

int lodFromDist(const float depth) {
  // NOTE: manual tuning been here
  if(depth < 0.25)
    return 0;
  if(depth < 0.5)
    return 0;
  if(depth <= 1)
    return 0;
  if(depth <= 1.5)
    return 0;
  if(depth <= 6.0)
    return 1;
  if(depth <= 9.0)
    return 2;
  return 3;
  }

void main_alloc() {
  screenSize = ivec2(textureSize(depth,0));
  fragCoord  = ivec2(gl_GlobalInvocationID.xy);
  threadId   = fragCoord.x + fragCoord.y*screenSize.x;

  const bool valid = all(lessThan(fragCoord, screenSize));
  if(!valid)
    return;

  vec3  norm = normalize(texelFetch(normals,fragCoord,0).xyz*2.0-vec3(1.0));
  float z    = texelFetch(depth,fragCoord,0).x;
  if(z>=0.99995)
    return; // sky

  const float dist    = linearDepth(z, scene.clipInfo);
  const vec3  pos     = unprojectDepth(z);

  const int   lod     = lodFromDist(dist);
  const float step    = gridStep*(1 << lod);
  const vec3  gridPos = pos/step;
  const ivec3 pLow    = ivec3(floor(gridPos));
  const ivec3 pHigh   = ivec3(ceil (gridPos));

  //processProbe(ivec3(round(gridPos)), pos, lod);

  [[unroll]]
  for(int x=0; x<=1; ++x) {
    [[unroll]]
    for(int y=0; y<=1; ++y) {
      [[unroll]]
      for(int z=0; z<=1; ++z) {
        ivec3 px = ivec3(x==0 ? pLow.x : pHigh.x,
                         y==0 ? pLow.y : pHigh.y,
                         z==0 ? pLow.z : pHigh.z);
        vec3 wpos = vec3(px)*step;
        vec3 dir  = (wpos-pos);
        if(dot(dir,norm)<=0)
          continue;

        processProbe(px, wpos, lod);
        //processProbe(px, pos, lod);
        }
      }
    }
  }

void main_clear() {
  const uint laneID = gl_GlobalInvocationID.x;

  if(laneID<hashTable.length()) {
    hashTable[laneID].value = 0xFFFFFFFF;
    }
  if(laneID==0)
    probeCount = 0;
  }

void main() {
#if defined(CLEAR)
  main_clear();
#else
  main_alloc();
#endif
  }
