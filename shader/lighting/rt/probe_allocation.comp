#version 450

#extension GL_EXT_control_flow_attributes : enable
#extension GL_GOOGLE_include_directive    : enable

#include "lighting/rt/probe_common.glsl"
#include "lighting/tonemapping.glsl"
#include "scene.glsl"
#include "common.glsl"

layout(local_size_x = 8, local_size_y = 8) in;

layout(binding = 0, std140) uniform UboScene {
  SceneDesc scene;
  };

layout(binding = 1) uniform sampler2D  gbufDiffuse;
layout(binding = 2) uniform usampler2D gbufNormal;
layout(binding = 3) uniform sampler2D  depth;
layout(binding = 4, std430) buffer          Hbo0 { uint voteTable[]; };
layout(binding = 5, std430) readonly buffer Hbo  { uint hashTable[]; };
layout(binding = 6, std430) buffer          Pbo  { ProbesHeader probeHeader; Probe probe[]; };
layout(binding = 7, std430) buffer          Fbo0 { int cursor; uint list[]; } freeList;
layout(binding = 8, r32ui) uniform uimage2D screenTiles;

shared ivec3 pLow, pHigh;
shared bool  rTile, uTile;
shared bool  uSky;

ivec2 screenSize, fragCoord;
ivec2 tileId;
uint  threadId;

vec3 unprojectDepth(const float z) {
  const vec2  inPos = vec2(2*fragCoord+ivec2(1,1))/vec2(screenSize)-vec2(1,1);
  const vec4  pos   = vec4(inPos.xy,z,1);
  const vec4  ret   = scene.viewProjectInv*pos;
  return (ret.xyz/ret.w);
  }

int probeGridComputeLod() {
  const float z = texelFetch(depth,fragCoord,0).x;
  return probeGridComputeLod(fragCoord, screenSize, z, scene.viewProjectInv);
  }

bool probeQueryInitialize(out probeQuery pq) {
  vec3  norm = normalFetch(gbufNormal, fragCoord);
  float z    = texelFetch(depth,fragCoord,0).x;
  if(z>=SKY_DEPTH)
    return false; // sky

  const int  lod     = probeGridComputeLod();
  const vec3 basePos = unprojectDepth(z);
  const vec3 pos     = basePos + norm*probeCageBias;
  probeQueryInitialize(pq, pos, lod);
  return true;
  }

uint allocProbe() {
  int cursor = atomicAdd(freeList.cursor, -1) - 1;
  if(cursor>=0)
    return freeList.list[cursor];
  return atomicAdd(probeHeader.count, 1);
  }

bool reuseProbe(const uint h, vec3 pos, int lod) {
  uint probeId = hashTable[h];
  if(probeId>=probeHeader.count)
    return false;

  [[loop]]
  for(int i=0; i<8; ++i) {
    Probe p = probe[probeId];
    if((p.bits & TRACED_BIT)==0) {
      probeId = p.pNext;
      continue;
      }
    if(!probeIsSame(p.pos, pos, lod)) {
      probeId = p.pNext;
      continue;
      }
    atomicOr(probe[probeId].bits, REUSE_BIT);
    return true;
    }

  return false;
  }

void processProbe(ivec3 gridPos, vec3 pos, int lod, vec3 pixelPos, vec3 pixelNorm) {
  const uint h = probeGridPosHash(gridPos) % hashTable.length();
#if defined(VOTE)
  if(reuseProbe(h, pos, lod))
    return;
  atomicMin(voteTable[h], threadId);
#elif defined(ALLOC)
  if(voteTable[h] != threadId)
    return;
  voteTable[h] = 0xFFFFFFFF;

  const uint cursor = allocProbe();
  if(cursor>=probe.length())
    return;
  Probe p;
  p.pos         = pos;
  p.pNext       = 0xFFFFFFFF;
  p.normal      = pixelNorm;
  p.bits        = 0;
  probe[cursor] = p;
#endif
  }

void mainClassify() {
  const bool valid = all(lessThan(fragCoord, screenSize));

  bool sky = false;
  probeQuery pq;
  if(valid)
    sky = !probeQueryInitialize(pq);

  if(gl_LocalInvocationIndex==0) {
    pLow  = pq.pLow;
    pHigh = pq.pHigh;
    uTile = !sky;
    uSky  = true;
    }
  barrier();

  if(valid && !sky)
    uSky = false;
  if(valid && (sky || pLow!=pq.pLow || pHigh!=pq.pHigh)) {
    uTile = false;
    }
  barrier();

  if(gl_LocalInvocationIndex!=0)
    return;

  const uint hint = (uTile || uSky) ? 1 : 0;
  imageStore(screenTiles, ivec2(gl_WorkGroupID.xy), uvec4(hint));
  }

void mainAlloc() {
  const bool valid = all(lessThan(fragCoord, screenSize));
  if(!valid)
    return;

  const uint tile = imageLoad(screenTiles, tileId).r;
#if defined(TILE) && defined(VOTE)
  if(tile==0)
    return;
#elif defined(VOTE)
  if(tile!=0)
    return;
#endif

  vec3  norm = normalFetch(gbufNormal, fragCoord);
  float z    = texelFetch(depth,fragCoord,0).x;
  if(z>=SKY_DEPTH)
    return; // sky

  const int  lod     = probeGridComputeLod();
  const vec3 basePos = unprojectDepth(z);
  const vec3 pos     = basePos + norm*probeCageBias;

  bool ret = true;
  probeQuery pq;
  probeQueryInitialize(pq, pos, lod);
  while(probeQueryProceed(pq)) {
    vec3 wpos = probeQueryWorldPos(pq);
    vec3 dir  = (wpos-basePos);
    if(dot(dir,norm) < -0.1)
      continue;

    ivec3 gPos = probeQueryGridPos(pq);
    processProbe(gPos, wpos, lod, basePos, norm);
    }
  }

void main() {
  screenSize = ivec2(textureSize(depth,0));
#if defined(TILE)
  tileId     = ivec2(gl_GlobalInvocationID.xy);
  fragCoord  = ivec2(gl_GlobalInvocationID.xy) * ivec2(gl_WorkGroupSize.xy);
#else
  tileId     = ivec2(gl_WorkGroupID.xy);
  fragCoord  = ivec2(gl_GlobalInvocationID.xy);
#endif
  threadId   = fragCoord.x + fragCoord.y*screenSize.x;

#if defined(CLASSIFY)
  mainClassify();
#else
  mainAlloc();
#endif
  }
