#version 450

#extension GL_ARB_separate_shader_objects      : enable
#extension GL_GOOGLE_include_directive         : enable
#extension GL_EXT_control_flow_attributes      : enable
#extension GL_EXT_samplerless_texture_functions : enable

#include "sky_common.glsl"
#include "scene.glsl"

layout(local_size_x = 8, local_size_y = 8) in;

//layout(binding = 0) uniform writeonly uimage2D result;
layout(binding = 0) uniform writeonly image2D result;
layout(binding = 1, std140) uniform UboScene {
  SceneDesc scene;
  };
layout(binding = 2) uniform sampler2D depth;
layout(binding = 3) uniform sampler2D shadowRq;

ivec2 invocationID = ivec2(gl_GlobalInvocationID.xy);

vec3 project(mat4 m, vec3 pos) {
  vec4 p = m*vec4(pos,1);
  return p.xyz/p.w;
  }

vec3 screenSun() {
  vec3 sun = scene.sunDir;
  sun = (scene.viewProject*vec4(sun,0)).xyz;
  sun.xy /= sun.z;
  return sun;
  }

vec2 findSlice(vec2 s) {
  vec2 sun = screenSun().xy;
  vec2 dv  = s - sun;

  vec2 ret = vec2(0);
  {
    float d = (dv.x<0 ? -1 : +1) - sun.x;

    ret = sun + dv*abs(d/dv.x);
    if(-1<=ret.y && ret.y<=1)
      ;//return ret;
  }
  {
    float d = (dv.y<0 ? -1 : +1) - sun.y;

    ret = sun + dv*abs(d/dv.y);
    if(-1<=ret.x && ret.x<=1)
      return ret;
  }

  return vec2(-1);
  }

float mapToSm(vec2 at) {
  //const ivec2 dstSz  = textureSize(shadowRq,0);
  if(at.y>0 && abs(at.x)<=1) {
    return (at.x*0.5+0.5);
    }
  return -1;
  }

void main() {
  const int   steps    = 32;
  const float dMin     = 0;
  const float dMax     = 0.9999;

  const ivec2 size = imageSize(result).xy;
  if(invocationID.x>=size.x || invocationID.y>=size.y)
    return;

  const vec2  fragCoord = (invocationID+vec2(0.5))/vec2(size);
  const vec2  inPos     = fragCoord*2.0-vec2(1.0);
  const vec2  slice     = findSlice(inPos);
  const float smX       = mapToSm(slice);
  if(smX<0) {
    imageStore(result, invocationID, vec4(0,0,0.5,0));
    return;
    }

  const float z      = textureLod(depth,fragCoord,0).r;

  const vec3  pos0   = project(scene.viewProjectInv, vec3(inPos, dMin));
  const vec3  pos1   = project(scene.viewProjectInv, vec3(inPos, dMax));
  const vec3  posz   = project(scene.viewProjectInv, vec3(inPos, z));

  vec3 dir  = pos1 - pos0;
  vec3 dirN = normalize(dir);
  vec3 tg   = cross(dirN, scene.sunDir);
  vec3 base = cross(tg,   scene.sunDir);
  if(dot(base,dir)<0)
    base = -base; //TODO

  {
    vec3 pos = posz - scene.camPos;

    float y = dot(base, pos)/length(pos1-pos0);
    imageStore(result, invocationID, vec4(smX,y,0,0));

    float shadow = textureLod(shadowRq, vec2(smX,y), 0).x;
    imageStore(result, invocationID, vec4(shadow));

    //imageStore(result, invocationID, vec4(slice,0,0));
    // return;
  }

  //const vec3  pos    = scene.camPos + dot(base*slice, dirN)*dir;

  uint occlusion = 0;
  [[dont_unroll]]
  for(uint i=0; i<steps; ++i) {
    float v      = (i+0.5)/float(steps);
    vec3  pos    = mix(pos0, posz, v) - scene.camPos;
    float y      = dot(base, pos)/length(pos1-pos0);
    vec2 smPos = vec2(smX,y);

    vec4  shPos0 = scene.viewShadow[1]*vec4(pos, 1);
    shPos0.xyz /= shPos0.w;

    bool  shadow = textureLod(shadowRq, smPos.xy, 0).x > shPos0.z;
    occlusion = occlusion | ((shadow ? 1u : 0u) << uint(i));
    }

  const float sm = 1.0 - bitCount(occlusion)/float(steps);
  imageStore(result, invocationID, vec4(sm));
  }
