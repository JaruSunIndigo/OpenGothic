#version 450

#extension GL_EXT_control_flow_attributes : enable
#extension GL_GOOGLE_include_directive    : enable

#include "scene.glsl"
#include "common.glsl"

layout(local_size_x = 8, local_size_y = 8) in;

layout(binding = 0) uniform writeonly image2D result;

layout(binding = 1, std140) uniform UboScene {
  SceneDesc scene;
  };
layout(binding = 2) uniform sampler2D textureSm1;

vec3 project(in mat4 m, vec3 v) {
  vec4 x = m*vec4(v,1);
  return x.xyz/x.w;
  }

vec2 invocationToPos(int ix) {
  const ivec2 dstSz  = imageSize(result);
  const int   width  = dstSz.x;
  const int   height = 256;

  if(ix<width)
    return vec2((float(ix+0.5)/float(width))*2.0-1.0, -1);
  ix -= width;

  //if(ix<width)
  //  return vec2(float(ix+0.5)/float(width), +1);
  //ix -= width;

  return vec2(0,0);
  }

void main() {
  const float dMin    = 0;
  const float dMax    = 0.9999;
  const float maxDist = 40000;

  const ivec2 dstSz  = imageSize(result);
  const ivec2 dstUV  = ivec2(gl_GlobalInvocationID.xy);

  const vec2  inPos  = invocationToPos(dstUV.x);
  const float slice  = float(dstUV.y+0.5)/float(dstSz.y);

  const vec3  pos0   = project(scene.viewProjectInv, vec3(inPos.x, 0, dMin));
  const vec3  pos1   = project(scene.viewProjectInv, vec3(inPos.x, 0, dMax));

  vec3 dir  = normalize(pos1 - pos0);
  vec3 tg   =  cross(dir, scene.sunDir);
  vec3 base = -cross(tg,  scene.sunDir) * maxDist;

  const vec3  pos    = scene.camPos + base*slice;
  const vec4  shPos0 = scene.viewShadow[1]*vec4(pos, 1);

  const vec2  shPos  = shPos0.xy/shPos0.w;
  const float sh     = textureLod(textureSm1, shPos.xy*0.5+0.5, 0).x;

  imageStore(result, ivec2(gl_GlobalInvocationID.xy), vec4(sh.x));
  if(abs(shPos.x)>1.0 || abs(shPos.y)>1.0)
    imageStore(result, ivec2(gl_GlobalInvocationID.xy), vec4(1,0,0,0));
  }
