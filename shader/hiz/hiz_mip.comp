#version 450

#extension GL_EXT_control_flow_attributes : enable
#extension GL_EXT_samplerless_texture_functions : enable

layout(local_size_x = 8, local_size_y = 8) in;

layout(binding = 0, std430)   buffer  coherent Cnt { uint counter; };
layout(binding = 1)           uniform texture2D           mip0;
layout(binding = 2, r16)      uniform writeonly image2D   mip1;
layout(binding = 3, r16)      uniform writeonly image2D   mip2;
layout(binding = 4, r16)      uniform writeonly image2D   mip3;
layout(binding = 5, r16)      uniform coherent  image2D   mip4;
layout(binding = 6, r16)      uniform writeonly image2D   mip5;
layout(binding = 7, r16)      uniform writeonly image2D   mip6;
layout(binding = 8, r16)      uniform writeonly image2D   mip7; // 128x128
//layout(binding = 9, r16)      uniform coherent image2D   mip8;

layout(push_constant, std140) uniform PushConstant {
  uint mipCount;
  };

shared float local[8][8];
shared uint  counterLast;
float zStore;

uint numGroups() {
  ivec2 srcSz = imageSize(mip1);
  srcSz.x = (srcSz.x+15)/16;
  srcSz.y = (srcSz.y+15)/16;
  return srcSz.x*srcSz.y;
  }

bool pull(ivec2 uv, const int mip, ivec2 dstSz) {
  const ivec2 at  = ivec2(gl_LocalInvocationID.xy);
  if(!all(lessThan(uv, dstSz))) {
    local[at.x][at.y] = 0;
    return false;
    }

  ivec2 srcSz  = textureSize(mip0, mip);
  ivec2 srcUV0 = uv*2;
  ivec2 srcUV1 = min(uv*2+1, srcSz-1);

  float z00 = texelFetch(mip0, ivec2(srcUV0.x, srcUV0.y), mip).x;
  float z01 = texelFetch(mip0, ivec2(srcUV0.x, srcUV1.y), mip).x;
  float z10 = texelFetch(mip0, ivec2(srcUV1.x, srcUV0.y), mip).x;
  float z11 = texelFetch(mip0, ivec2(srcUV1.x, srcUV1.y), mip).x;

  float z   = max(max(z00, z01), max(z10, z11));
  zStore            = z;
  local[at.x][at.y] = z;
  return true;
  }

bool reduce(ivec2 uv, int size, ivec2 dstSz) {
  const ivec2 at = ivec2(gl_LocalInvocationID.xy);
  if(!all(lessThan(uv/size, dstSz)))
    return false;

  if(uv.x%size!=0 || uv.y%size!=0)
    return false;

  int   s   = size/2;
  float z00 = local[at.x+0][at.y+0];
  float z01 = local[at.x+0][at.y+s];
  float z10 = local[at.x+s][at.y+0];
  float z11 = local[at.x+s][at.y+s];

  float z   = max(max(z00, z01), max(z10, z11));
  zStore            = z;
  local[at.x][at.y] = z;
  return true;
  }

void main() {
  counterLast = 0; // iOS warnings
  ivec2 uv = ivec2(gl_GlobalInvocationID.xy);

  if(pull(uv, 0, imageSize(mip1))) {
    imageStore(mip1, uv, vec4(zStore));
    }
  barrier();

  if(reduce(uv, 2, imageSize(mip2))) {
    imageStore(mip2, uv/2, vec4(zStore));
    }
  barrier();

  if(reduce(uv, 4, imageSize(mip3))) {
    imageStore(mip3, uv/4, vec4(zStore));
    }
  barrier();
 
  if(reduce(uv, 8, imageSize(mip4))) {
    imageStore(mip4, uv/8, vec4(zStore));
    }
  barrier();

  if(gl_LocalInvocationIndex==0) {
    counterLast = atomicAdd(counter, 1);
    }
  barrier();

  if(counterLast+1 != numGroups())
    return;
  barrier();
  /* Spec (OpMemoryBarrier/ImageMemory):
     Apply the memory-ordering constraints to image contents (types declared by OpTypeImage),
     or to accesses done through pointers to the Image Storage Class.

     Both texture2D and image2D are OpTypeImage in spirv.
   */
  memoryBarrierImage();
  counter = 0;

  // tail phase
  uv = ivec2(gl_LocalInvocationID.xy);
  if(pull(uv, 4, imageSize(mip5))) {
    imageStore(mip5, uv, vec4(zStore));
    }
  barrier();

  if(reduce(uv, 2, imageSize(mip6))) {
    imageStore(mip6, uv/2, vec4(zStore));
    }
  barrier();

  if(reduce(uv, 4, imageSize(mip7))) {
    imageStore(mip7, uv/4, vec4(zStore));
    }
  //barrier();
  }
