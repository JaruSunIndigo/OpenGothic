#version 450

#extension GL_ARB_separate_shader_objects : enable
#extension GL_GOOGLE_include_directive : enable
#extension GL_EXT_control_flow_attributes : enable

#include "scalar_ops.glsl"
#include "materials_common.glsl"

layout(local_size_x = 64) in;

layout(binding = 1, std430) buffer IndirectBuf  { IndirectCmd cmd[];         };
layout(binding = 2, std430) readonly buffer Cbo { Cluster     clusters[];    };
layout(binding = 3, std430) buffer SsboGlob     { uvec4       payload[];     };
layout(binding = 4, std430) readonly buffer Mem { uint        instanceMem[]; };
layout(binding = 5)         uniform sampler2D hiZ;

Cluster cluster;

float hiZFetch(in sampler2D hiZ, in ivec2 ibbox[2]) {
  if(ibbox[0]==ibbox[1])
    return texelFetch(hiZ, ibbox[0], 0).x;

  const uint sz  = max(ibbox[1].x-ibbox[0].x, ibbox[1].y-ibbox[0].y);
  const int  mip = findMSB(sz - 1) + 1; // log2 of next pot

  ibbox[0].x = (ibbox[0].x >> mip);
  ibbox[0].y = (ibbox[0].y >> mip);

  ivec2 hiZsize = textureSize(hiZ,mip);
  float z =  texelFetchOffset(hiZ, ibbox[0], mip, ivec2(0,0)).x;
  if(ibbox[0].x+1<hiZsize.x)
    z = max(z, texelFetchOffset(hiZ, ibbox[0], mip, ivec2(1,0)).x);
  if(ibbox[0].y+1<hiZsize.y)
    z = max(z, texelFetchOffset(hiZ, ibbox[0], mip, ivec2(0,1)).x);
  if(ibbox[0].x+1<hiZsize.x && ibbox[0].y+1<hiZsize.y)
    z = max(z, texelFetchOffset(hiZ, ibbox[0], mip, ivec2(1,1)).x);

  return z;
  }

bool sphereTest(const vec4 sphere) {
  if(sphere.w<0.f)
    return false;

  for(int i=0; i<6; ++i) {
    if(dot(vec4(sphere.xyz,1.0), scene.frustrum[i]) <= -sphere.w) {
      return false;
      }
    }

  return true;
  }

bool hiZTest(ivec4 ibbox, float depthMin) {
  ivec2 bbox[2] = {ibbox.xy, ibbox.zw};
  float bz      = packHiZ(depthMin);
  float z       = hiZFetch(hiZ, bbox);
  if(bz > z)
    return false;
  return true;
  }

ivec4 bboxCluster(out float depthMin) {
  const vec3  objPos = cluster.sphere.xyz;
  const float R      = cluster.sphere.w;
  const vec3  b[2]   = { objPos-vec3(R), objPos+vec3(R) };

  vec2  sbbox[2] = {vec2(1), vec2(-1)};
  depthMin = 1;
  for(uint i=0; i<8; ++i) {
    const vec3 pos = vec3(b[bitfieldExtract(i,0,1)].x,
                          b[bitfieldExtract(i,1,1)].y,
                          b[bitfieldExtract(i,2,1)].z);
    vec4 trPos = vec4(pos,1.0);
    trPos = scene.viewProject*trPos;
    if(trPos.z<0 || trPos.w<0.001) {
      depthMin = 0;
      continue;
      }

    vec3 bp = trPos.xyz/trPos.w;
    bp.xy = bp.xy*0.5 + vec2(0.5);

    sbbox[0] = min(sbbox[0], bp.xy);
    sbbox[1] = max(sbbox[1], bp.xy);

    depthMin = min(depthMin, bp.z);
    }

  ivec2 hiZsize = textureSize(hiZ,0);
  ivec2 ibbox[2];
  ibbox[0] = ivec2(sbbox[0] * scene.screenRes) / scene.hiZTileSize;
  ibbox[1] = ivec2(sbbox[1] * scene.screenRes) / scene.hiZTileSize;
  ibbox[0] = clamp(ibbox[0], ivec2(0), hiZsize - ivec2(1));
  ibbox[1] = clamp(ibbox[1], ivec2(0), hiZsize - ivec2(1));

  return ivec4(ibbox[0], ibbox[1]);
  }

#if defined(HIZ) && 0
bool bboxTest(const uint instanceId) {
#if defined(LVL_OBJECT)
  const vec3  b[2]   = {bucket.bbox[0].xyz, bucket.bbox[1].xyz};
  Instance    obj    = pullInstance(instanceId);
#else
  const vec3  objPos = cluster.sphere.xyz;
  const float R      = cluster.sphere.w;
  const vec3  b[2]   = { objPos-vec3(R), objPos+vec3(R) };
#endif

  ivec2 hiZsize  = textureSize(hiZ,0);
  ivec2 ibbox[2] = {ivec2(hiZsize), ivec2(0)};
  vec2  sbbox[2] = {vec2(1), vec2(-1)};
  float depthMin = 1;
  for(uint i=0; i<8; ++i) {
    const vec3 pos = vec3(b[bitfieldExtract(i,0,1)].x,
                          b[bitfieldExtract(i,1,1)].y,
                          b[bitfieldExtract(i,2,1)].z);
    vec4 trPos = vec4(pos,1.0);
#if defined(LVL_OBJECT)
    trPos = vec4(obj.mat*trPos, 1.0);
#endif
    trPos = scene.viewProject*trPos;
    if(trPos.z<0 || trPos.w<0.001)
      return true;

    vec3 bp = trPos.xyz/trPos.w;
    bp.xy = bp.xy*0.5 + vec2(0.5);

    ivec2 scr = ivec2(bp.xy * scene.screenRes) / scene.hiZTileSize;

    ibbox[0] = min(ibbox[0], scr);
    ibbox[1] = max(ibbox[1], scr);

    sbbox[0] = min(sbbox[0], bp.xy);
    sbbox[1] = max(sbbox[1], bp.xy);

    depthMin = min(depthMin, bp.z);
    }

  sbbox[0] *= scene.screenRes;
  sbbox[1] *= scene.screenRes;
  if(round(sbbox[0])==round(sbbox[1]))
    return false;

  ibbox[0] = clamp(ibbox[0], ivec2(0), hiZsize - ivec2(1));
  ibbox[1] = clamp(ibbox[1], ivec2(0), hiZsize - ivec2(1));

  float bz = packHiZ(depthMin);
  float z  = hiZFetch(hiZ, ibbox);
  if(bz > z)
    return false;
  return true;
  }
#else
bool bboxTest(const uint instanceId) {
  return true;
  }
#endif

void runCluster(const uint clusterId) {
  cluster = clusters[clusterId];
  if(!sphereTest(cluster.sphere))
    return;

  const uint commandId  = cluster.bucketId_commandId & 0xFFFF;
  const uint bucketId   = cluster.bucketId_commandId >> 16;
  const uint instanceId = cluster.instanceId;
  const uint meshletId  = cluster.firstMeshlet;

#if defined(HIZ)
  {
  float depthMin = 1;
  ivec4 bbox     = bboxCluster(depthMin);
  if(!hiZTest(bbox, depthMin))
    return;
  }
#endif

  uint writeOffset = cmd[commandId].writeOffset;
  writeOffset      += atomicAdd(cmd[commandId].instanceCount, cluster.meshletCount);

  for(int i=0; i<cluster.meshletCount; ++i)
    payload[writeOffset+i] = uvec4(instanceId, meshletId+i, bucketId, 0);
  }

void main() {
  const uint clusterId = gl_GlobalInvocationID.x;
  if(clusterId<push.meshletCount)
    runCluster(clusterId);
  }
