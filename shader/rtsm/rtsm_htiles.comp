#version 450

#extension GL_GOOGLE_include_directive : enable

#include "rtsm/rtsm_common.glsl"
#include "scene.glsl"
#include "common.glsl"

layout(local_size_x = 32, local_size_y = 16) in;

const uint NumThreads = gl_WorkGroupSize.x*gl_WorkGroupSize.y*gl_WorkGroupSize.z;

layout(binding = 0)         uniform texture2D   outputImage;
layout(binding = 1, std140) uniform UboScene    { SceneDesc scene;   };
layout(binding = 2)         uniform texture2D   depth;
layout(binding = 3, std430)         buffer CB   { uvec4 cmd;   uint tiles[]; } largeTile;
layout(binding = 4, std430)         buffer Pos  { uint  alloc; uint data[];  } pos;
layout(binding = 5, rg32ui) uniform writeonly uimage2D tileBins;
layout(binding = 6, r32ui)  uniform uimage2D           dbgImage;

#include "rtsm/rtsm_scratch.glsl"

// tiles: 128 -> 32
// 5'576 bytes + ~10kb for lists
shared uvec4 rayTileBbox[(1+16)*MaxSlices];
shared uint  rayDepthMin[(1+16)*MaxSlices];
shared uint  numSlices  [(1+16)];

shared uint  meshletsIdGlob[2048];
shared uint  numMeshletsGlob;

shared uint  meshletsId[256];
shared uint  numMeshlets;

shared uint  meshListPtr;

void storeFullList(ivec2 tileId) {
  if(any(greaterThanEqual(tileId, imageSize(tileBins))))
    return;

  const uvec2 l = uvec2(1, pos.data[0]);
  imageStore(tileBins, tileId, uvec4(l, 0, 0));
  imageStore(dbgImage, tileId, uvec4(l.y));
  if(gl_LocalInvocationIndex!=0)
    return;

  const uint id = atomicAdd(largeTile.cmd.x, 1);
  largeTile.tiles[id] = packUint2x16(tileId);
  }

void storeEmptyList(ivec2 tileId) {
  if(all(lessThan(tileId, imageSize(tileBins)))) {
    imageStore(tileBins, tileId, uvec4(NULL));
    imageStore(dbgImage, tileId, uvec4(0));
    }
  }

void storeFullList() {
  for(int i=0; i<16; ++i) {
    const ivec2 at = ivec2(gl_WorkGroupID.xy)*4 + ivec2(i%4, i/4);
    storeFullList(at);
    }
  }

void storeEmptyList() {
  for(int i=0; i<16; ++i) {
    const ivec2 at = ivec2(gl_WorkGroupID.xy)*4 + ivec2(i%4, i/4);
    storeEmptyList(at);
    }
  }

void storeMeshList(ivec2 tileId) {
  const uint laneID = gl_LocalInvocationIndex;

  if(numMeshlets>=meshletsId.length()) {
    storeFullList(tileId);
    return;
    }

  if(laneID==0) {
    meshListPtr = numMeshlets==0 ? NULL : atomicAdd(pos.alloc, numMeshlets);
    if(meshListPtr+numMeshlets>pos.data.length()) {
      // out of memory
      meshListPtr = NULL;
      numMeshlets = 0;
      }
    imageStore(tileBins, tileId, uvec4(meshListPtr, numMeshlets, 0, 0));
    imageStore(dbgImage, tileId, uvec4(numMeshlets));
    }
  barrier();

  // store pointer to meshlets list and list-data
  for(uint i=laneID; i<numMeshlets; i+=NumThreads)
    pos.data[meshListPtr + i] = meshletsId[i];
  }

// ray related
vec3 rayOrigin(ivec2 frag, float depth) {
  const vec2 fragCoord = ((frag.xy+0.5)*scene.screenResInv)*2.0 - vec2(1.0);
  const vec4 scr       = vec4(fragCoord.x, fragCoord.y, depth, 1.0);

  const vec4 wpos  = scene.viewProjectLwcInv * scr; //TODO: premul matrix
  const vec4 shPos = scene.viewVirtualShadowLwc * wpos;

  return shPos.xyz/shPos.w;
  }

uint depthSlice(const float z) {
  float dZ   = linearDepth(z,      scene.clipInfo);
  float d0   = linearDepth(0,      scene.clipInfo);
  float d1   = linearDepth(0.9999, scene.clipInfo);
  float d    = (dZ-d0)/(d1-d0);

  return min(uint(d*MaxSlices), MaxSlices-1);
  }

// fragments/tiles
void processFragment(const ivec2 fragCoord, const ivec2 tile) {
  const float lamb   = texelFetch(outputImage, fragCoord, 0).x;
  const bool  actRay = (lamb>0);
  if(!actRay)
    return;

  const float z = texelFetch(depth, fragCoord, 0).x;
  if(z==1.0)
    return;

  const uint slice = depthSlice(z);
  const vec3 ray   = rayOrigin(fragCoord, z);
  const uint bin   = (1 + tile.x + tile.y*4);
  const uint tid   = bin*MaxSlices + slice;

  atomicMin(rayTileBbox[tid].x, floatToOrderedUint(ray.x));
  atomicMin(rayTileBbox[tid].y, floatToOrderedUint(ray.y));
  atomicMax(rayTileBbox[tid].z, floatToOrderedUint(ray.x));
  atomicMax(rayTileBbox[tid].w, floatToOrderedUint(ray.y));
  atomicMin(rayDepthMin[tid],   floatToOrderedUint(ray.z));
  atomicOr (numSlices  [bin], 1u << slice);
  }

void tileBboxes(const ivec2 lTile) {
  const uint  laneID  = gl_LocalInvocationIndex;

  for(uint i=laneID; i<rayTileBbox.length(); i+=NumThreads) {
    rayTileBbox[i] = uvec4(0xFFFFFFFF, 0xFFFFFFFF, 0, 0);
    rayDepthMin[i] = 0xFFFFFFFF;
    numSlices  [i] = 0;
    }
  barrier();

  const uvec2 srcSz  = textureSize(depth,0);
  const ivec2 tileSz = ivec2(RTSM_LARGE_TILE);

  const ivec2 at0 = ivec2(lTile) * tileSz;
  const ivec2 xy0 = ivec2(gl_LocalInvocationID.xy);
  for(int x=xy0.x; x<tileSz.x; x+=int(gl_WorkGroupSize.x)) {
    for(int y=xy0.y; y<tileSz.y; y+=int(gl_WorkGroupSize.y)) {
      ivec2 at = at0 + ivec2(x,y);
      if(any(greaterThanEqual(at,srcSz)))
        continue;
      processFragment(at, ivec2(x,y)/RTSM_SMALL_TILE);
      }
    }
  barrier();

  for(uint i=MaxSlices+laneID; i<rayTileBbox.length(); i+=NumThreads) {
    const uint slice = i % MaxSlices;
    atomicMin(rayTileBbox[slice].x, rayTileBbox[i].x);
    atomicMin(rayTileBbox[slice].y, rayTileBbox[i].y);
    atomicMax(rayTileBbox[slice].z, rayTileBbox[i].z);
    atomicMax(rayTileBbox[slice].w, rayTileBbox[i].w);
    atomicMin(rayDepthMin[slice],   rayDepthMin[i]);
    }
  if(laneID<16)
    atomicOr(numSlices[0], numSlices[laneID+1]);
  barrier();

  vec4 rbb; float rayD;
  if(laneID<rayTileBbox.length()) {
    rbb  = orderedUintToFloat(rayTileBbox[laneID]);
    rayD = orderedUintToFloat(rayDepthMin[laneID]);
    }
  barrier();

  const uint srcBin   = laneID / MaxSlices;
  const uint srcSlice = laneID % MaxSlices;
  if(laneID<rayTileBbox.length() && (numSlices[srcBin] & (1u << srcSlice))!=0) {
    const uint i = bitCount(numSlices[srcBin] & ((1u << srcSlice)-1u));
    rayTileBbox[srcBin*MaxSlices + i] = floatBitsToUint(rbb);
    rayDepthMin[srcBin*MaxSlices + i] = floatBitsToUint(rayD);
    }
  barrier();

  if(laneID<numSlices.length())
    numSlices[laneID] = bitCount(numSlices[laneID]);
  }

// meshlets
bool isAabbVisible(const vec4 aabb, const float depthMax, const uint id) {
  const uint num = numSlices[id];
  const uint tid = id*MaxSlices;

  for(uint i=0; i<num; ++i) {
    vec4  rbb  = uintBitsToFloat(rayTileBbox[tid + i]);
    float rayd = uintBitsToFloat(rayDepthMin[tid + i]);
    if(rayd > depthMax)
      continue;
    if(!bboxIntersect(aabb, rbb))
      continue;
    return true;
    }
  return false;
  }

bool isMeshletVisible(uint ptr, const uint tileId) {
  vec4  aabb     = pullMeshAabb(ptr);
  float depthMax = pullMeshDepthMax(ptr);
  return isAabbVisible(aabb, depthMax, tileId+1);
  }

bool isMeshletVisible(uint ptr) {
  // global
  vec4  aabb     = pullMeshAabb(ptr);
  float depthMax = pullMeshDepthMax(ptr);
  return isAabbVisible(aabb, depthMax, 0);
  }

void traceMeshlets(const uint tileId) {
  const uint laneID = gl_LocalInvocationIndex;

  numMeshlets = 0;
  barrier();

  for(uint i=laneID; i<numMeshletsGlob; i+=NumThreads) {
    const uint ptr = meshletsIdGlob[i];
    if(!isMeshletVisible(ptr, tileId))
      continue;
    const uint id = atomicAdd(numMeshlets,1);
    if(id>=meshletsId.length())
      continue; //overflow
    meshletsId[id] = ptr;
    }
  }

void traceMeshlets(const uint tilePtr, const uint visCount) {
  const uint laneID = gl_LocalInvocationIndex;

  numMeshletsGlob = 0;
  barrier();

  for(uint i=laneID; i<visCount; i+=NumThreads) {
    const uint ptr = pos.data[tilePtr + i];
    if(!isMeshletVisible(ptr))
      continue;

    const uint id = atomicAdd(numMeshletsGlob,1);
    if(id>=meshletsIdGlob.length())
      break; // slow-path, with indirect dispatch
    meshletsIdGlob[id] = ptr;
    }
  barrier();

  if(numMeshletsGlob>meshletsIdGlob.length()) {
    storeFullList();
    return;
    }

  for(int i=0; i<16; ++i) {
    const ivec2 at  = ivec2(gl_WorkGroupID.xy)*4 + ivec2(i%4, i/4);
    const uint  tid = 1 + i;
    if(numSlices[tid]==0) {
      storeEmptyList(at);
      continue;
      }

    traceMeshlets(i);
    barrier();

    storeMeshList(at);
    barrier();
    // imageStore(tileBins, at, uvec4(NULL, numMeshlets, 0, 0));
    }
  }

void main() {
  tileBboxes(ivec2(gl_WorkGroupID.xy));
  barrier();

  if(numSlices[0]==0) {
    storeEmptyList();
    return;
    }

  traceMeshlets(1, pos.data[0]);
  return;

  // debug
  barrier();
  for(int i=0; i<16; ++i) {
    ivec2 at = ivec2(gl_WorkGroupID.xy)*4 + ivec2(i%4, i/4);
    imageStore(tileBins, at, uvec4(numMeshletsGlob));
    }
  }
