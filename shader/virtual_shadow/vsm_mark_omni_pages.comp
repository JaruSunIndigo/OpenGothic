#version 450

#extension GL_GOOGLE_include_directive    : enable
#extension GL_ARB_separate_shader_objects : enable
#extension GL_EXT_samplerless_texture_functions : enable
// #extension GL_KHR_memory_scope_semantics : enable

#define LWC 1

#include "virtual_shadow/vsm_common.glsl"
#include "lighting/tonemapping.glsl"
#include "scene.glsl"
#include "common.glsl"

layout(local_size_x = 16, local_size_y = 16) in;

const uint NumThreads = gl_WorkGroupSize.x*gl_WorkGroupSize.y*gl_WorkGroupSize.z;

layout(std140, push_constant) uniform Push {
  vec3  originLwc;
  float znear;
  float vsmMipBias;
  };
layout(binding = 0, std140) uniform UboScene { SceneDesc scene; };
layout(binding = 1)         uniform texture2D  gbufDiffuse;
layout(binding = 2)         uniform utexture2D gbufNormal;
layout(binding = 3)         uniform texture2D  depth;
layout(binding = 4, std430) readonly buffer Lbo { LightSource  lights[]; };
layout(binding = 5, r32ui)  uniform uimage2D   dbgImg;

shared uint  tileDepthMin, tileDepthMax;
shared uint  lightCount;
shared uint  lightId[NumThreads];
shared uint  lightMask[NumThreads/32];

shared uint  lightFineCount;

ivec2 fragCoord    = ivec2(gl_GlobalInvocationID.xy);
ivec2 viewportSize = textureSize(depth, 0);

vec4 worldPos(ivec2 frag, float depth) {
  const vec2 fragCoord = ((frag.xy+0.5)*scene.screenResInv)*2.0 - vec2(1.0);
  const vec4 scr       = vec4(fragCoord.x, fragCoord.y, depth, 1.0);
  return scene.viewProjectLwcInv * scr;
  }

bool projectSphere(const vec4 sphere, out vec4 aabb, out float depthMin, out float depthMax) {
  const vec3  c     = (scene.view * vec4(sphere.xyz, 1)).xyz;
  const float R     = sphere.w;

  depthMin  = scene.project[3][2]/max(c.z - R, znear) + scene.project[2][2];
  depthMax  = scene.project[3][2]/max(c.z + R, znear) + scene.project[2][2];
  if(c.z - R < znear) {
    aabb = vec4(0,0,1,1);
    return true;
    }

  float z   = c.z - R;
  float P00 = scene.project[0][0];
  float P11 = scene.project[1][1];

  vec3  cr   = c * R;
  float czr2 = c.z * c.z - R * R;

  float vx   = sqrt(c.x * c.x + czr2);
  float minx = (vx * c.x - cr.z) / (vx * c.z + cr.x);
  float maxx = (vx * c.x + cr.z) / (vx * c.z - cr.x);

  float vy   = sqrt(c.y * c.y + czr2);
  float miny = (vy * c.y - cr.z) / (vy * c.z + cr.y);
  float maxy = (vy * c.y + cr.z) / (vy * c.z - cr.y);

  aabb = vec4(minx * P00, miny * P11, maxx * P00, maxy * P11);
  aabb = aabb*0.5 + vec4(0.5);
  return true;
  }

void hiTile(float depth) {
  uint d = floatBitsToUint(depth);
  atomicMax(tileDepthMax, d);
  atomicMin(tileDepthMin, d);
  }

void processLightTiles(const vec3 pos, const vec3 normal) {
  const uint count = lightCount;

  for(uint i=0; i<count; ++i) {
    const LightSource lx             = lights[lightId[i]];
    const vec3        ldir           = (lx.pos - pos);
    const float       distanceSquare = dot(ldir,ldir);
    const float       rangeSquare    = lx.range*lx.range;
    if(rangeSquare < distanceSquare)
      continue;
    if(dot(normal, ldir) < 0)
      continue;
    atomicOr(lightMask[i/32], 1u<<(i%32));
    }
  barrier();

  for(uint i=gl_LocalInvocationIndex; i<lightMask.length(); i+=NumThreads)
    atomicAdd(lightFineCount, bitCount(lightMask[i]));
  }

void processLights(const vec3 pos, const vec3 normal) {
  const uint  laneId   = gl_LocalInvocationIndex;
  const float tMin     = uintBitsToFloat(tileDepthMin);
  const float tMax     = uintBitsToFloat(tileDepthMax);
  const ivec2 TileSize = ivec2(gl_WorkGroupSize.xy);
  const ivec2 begin    = ivec2(gl_WorkGroupID.xy * TileSize + gl_LocalInvocationID.xy);
  const ivec2 end      = ivec2(gl_WorkGroupID.xy * TileSize + TileSize);

  vec4  aabb     = vec4(0);
  float depthMin = 0;
  float depthMax = 0;

  for(uint i=laneId; i<lights.length(); i+=NumThreads) {
    if(i+1!=lights.length())
      ;//continue;
    if(!projectSphere(vec4(lights[i].pos, lights[i].range), aabb, depthMin, depthMax))
      continue;
    if(depthMin>tMax)
      continue;
    if(depthMax<tMin)
      continue;

    aabb *= vec4(viewportSize, viewportSize);
    if(aabb.z<begin.x || end.x<=aabb.x ||
       aabb.w<begin.y || end.y<=aabb.y)
      continue;

    uint ix = atomicAdd(lightCount, 1);
    if(ix>=lightId.length())
      break; //TODO: incremental processing
    lightId[ix] = i;
    }

  barrier();
  processLightTiles(pos, normal);
  }

void main() {
  const uint  laneId = gl_LocalInvocationIndex;
  const ivec2 size   = textureSize(depth, 0);
  const bool  valid  = all(lessThan(fragCoord, size));

  lightFineCount = 0;
  lightCount   = 0;
  tileDepthMin = floatBitsToUint(1);
  tileDepthMax = floatBitsToUint(0);
  for(uint i=laneId; i<lightMask.length(); i+=NumThreads)
    lightMask[i] = 0;
  barrier();

  const float z      = valid ? texelFetch(depth, fragCoord, 0).x  : 1;
  const vec3  normal = valid ? normalFetch(gbufNormal, fragCoord) : vec3(0);
  if(z<1)
    hiTile(z);
  barrier();

  const vec4 wpos = worldPos(ivec2(fragCoord.xy), z) + vec4(normal*0.002, 0);
  const vec3 pos  = wpos.xyz/wpos.w + originLwc;

  processLights(pos, normal);
  barrier();

  // imageStore(dbgImg, fragCoord, uvec4(lightCount));
  imageStore(dbgImg, fragCoord, uvec4(lightFineCount));
  }
